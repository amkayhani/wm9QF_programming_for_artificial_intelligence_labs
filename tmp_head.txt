<!--
module_id: data_structures_advanced/vis_demo
author:   Amir Kayhani
email:    Amir.kayhani@warwick.ac.uk
version: 0.0.1
current_version_description: Initial version
module_type: standard
docs_version: 2.0.0
language: en
narrator: UK English Female
mode: Textbook
title: data_structures_advanced/vis_demo
comment:  A demo of visualisations for algorithms
estimated_time_in_minutes: 20

link:  ../assets/styles.css
import: ../module_templates/macros.md
import: ../module_templates/macros_algo_visualisations.md
import: ../module_templates/macros_python.md
import: https://dscroft.github.io/Pyodide/README.md
import: https://github.com/LiaScript/CodeRunner/blob/master/README.md

-->

# Attribution

@algo_attribution



# Queues in Python

Queues are a fundamental data structure in computer science, used in various applications such as task scheduling, breadth-first search, and buffering. This section provides a comprehensive guide to understanding, implementing, and applying queues in Python. It includes explanations, Python code examples, diagrams, and exercises to solidify your understanding.

---

## 1. Introduction to Queues

A queue is a linear data structure that follows the First In First Out (FIFO) principle. The element added first is the one to be removed first. Queues are widely used in scenarios where order needs to be preserved.

### Key Operations:
- **Enqueue**: Add an element to the rear of the queue.
- **Dequeue**: Remove an element from the front of the queue.
- **Peek**: View the front element without removing it.
- **isEmpty**: Check if the queue is empty.

### Real-World Applications:
- Task scheduling in operating systems.
- Breadth-first search in graph algorithms.
- Managing requests in web servers.

---

## 2. Implementing Queues in Python

### Using Lists
Python lists can mimic a queue for small workloads or quick prototypes, but removing from the front is costly because every remaining element must shift left. This makes lists useful for teaching FIFO behaviour, while highlighting why specialised queue types exist for production code.

**How the walkthrough progresses**
1. Begin with an empty list.
2. Append three numbers, so the queue becomes `[1, 2, 3]`.
3. Dequeue with `pop(0)`, which shifts the remaining numbers left; the queue now holds `[2, 3]`.
4. Print statements confirm both the dequeued value and the final state that the diagram illustrates.

@info Complexity snapshot
- Enqueue via `append(...)` is amortised `O(1)`.
- Dequeue via `pop(0)` is `O(n)` because of element shifting.
- Peek with `queue[0]` would be `O(1)`.

```python
# Queue implemented with a Python list (educational example).
queue = []

# Enqueue three items (FIFO order of arrival).
queue.append(1)
queue.append(2)
queue.append(3)
print("Queue after enqueuing:", queue)

# Dequeue the oldest item (expensive O(n) operation).
removed = queue.pop(0)
print("Dequeued element:", removed)
print("Queue after dequeuing:", queue)
```
@Pyodide.eval

![Visualization of Queue Operations Using Lists](../assets/media/queues/queue_list.svg)

### Using `collections.deque`
The `deque` class from the `collections` module is optimized for fast appends and pops from both ends.

```python
from collections import deque

# Queue implementation using deque
queue = deque()

# Enqueue
queue.append(1)
queue.append(2)
queue.append(3)
print("Queue after enqueuing:", queue)

# Dequeue
print("Dequeued element:", queue.popleft())
print("Queue after dequeuing:", queue)
```
@Pyodide.eval

![Visualization of Queue Operations Using deque](../assets/media/queues/queue_deque.svg)

### Using `queue.Queue`
The `queue.Queue` class is thread-safe and suitable for multi-threaded applications.

```python
from queue import Queue

# Queue implementation using queue.Queue
queue = Queue()

# Enqueue
queue.put(1)
queue.put(2)
queue.put(3)
print("Queue size:", queue.qsize())

# Dequeue
print("Dequeued element:", queue.get())
print("Queue size after dequeuing:", queue.qsize())
```
@Pyodide.eval

![Visualization of Queue Operations Using queue.Queue](../assets/media/queues/queue_queue_module.svg)

---

## 3. Types of Queues

### 3.1 Simple Queue
A basic FIFO queue. Suitable for scenarios requiring strict order.

```python
from collections import deque

class SimpleQueue:
    def __init__(self):
        self._q = deque()

    def enqueue(self, item):
        self._q.append(item)

    def dequeue(self):
        if self.is_empty():
            raise IndexError("dequeue from empty queue")
        return self._q.popleft()

    def peek(self):
        if self.is_empty():
            raise IndexError("peek from empty queue")
        return self._q[0]

    def is_empty(self):
        return len(self._q) == 0

# Demo
sq = SimpleQueue()
sq.enqueue(10)
sq.enqueue(20)
print("Front element:", sq.peek())
print("Dequeued element:", sq.dequeue())
```
@Pyodide.eval

![Visualization of Simple Queue Operations](../assets/media/queues/simple_queue.svg)

### 3.2 Circular Queue
Efficient for fixed-size buffers. Avoids shifting elements.

```python
class CircularQueue:
    def __init__(self, capacity):
        self._data = [None] * capacity
        self._head = 0
        self._tail = 0
        self._count = 0
        self._cap = capacity

    def enqueue(self, item):
        if self.is_full():
            raise OverflowError("Queue is full")
        self._data[self._tail] = item
        self._tail = (self._tail + 1) % self._cap
        self._count += 1

    def dequeue(self):
        if self.is_empty():
            raise IndexError("Queue is empty")
        item = self._data[self._head]
        self._data[self._head] = None
        self._head = (self._head + 1) % self._cap
        self._count -= 1
        return item

    def is_empty(self):
        return self._count == 0

    def is_full(self):
        return self._count == self._cap

# Demo
cq = CircularQueue(3)
cq.enqueue(1)
cq.enqueue(2)
print("Dequeued element:", cq.dequeue())
```
@Pyodide.eval

![Visualization of Circular Queue Operations](../assets/media/queues/deque.svg)

### 3.3 Priority Queue
Processes elements based on priority rather than order.

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self._heap = []

    def push(self, priority, item):
        heapq.heappush(self._heap, (priority, item))

    def pop(self):
        if not self._heap:
            raise IndexError("pop from empty priority queue")
        return heapq.heappop(self._heap)

# Demo
pq = PriorityQueue()
pq.push(2, "Task 2")
pq.push(1, "Task 1")
print("Popped element:", pq.pop())
```
@Pyodide.eval

![Visualization of Priority Queue Operations](../assets/media/queues/priority_queue.svg)

---

## 4. Applications of Queues
